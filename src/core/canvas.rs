// Copyright (c) 2023 Xu Shaohua <shaohua@biofan.org>. All rights reserved.
// Use of this source is governed by Lesser General Public License that can be found
// in the LICENSE file.

//! Canvas provides an interface for drawing, and how the drawing is clipped and transformed.
//!
//! Canvas contains a stack of Matrix and clip values.
//!
//! Canvas and Paint together provide the state to draw into Surface or `BaseDevice`.
//! Each Canvas draw call transforms the geometry of the object by the concatenation of all
//! Matrix values in the stack. The transformed geometry is clipped by the intersection
//! of all of clip values in the stack. The Canvas draw calls use Paint to supply drawing
//! state such as color, Typeface, text size, stroke width, Shader and so on.
//!
//! To draw to a pixel-based destination, create raster surface or GPU surface.
//! Request Canvas from Surface to obtain the interface to draw.
//! Canvas generated by raster surface draws to memory visible to the CPU.
//! Canvas generated by GPU surface uses Vulkan or OpenGL to draw to the GPU.
//!
//! To draw to a document, obtain Canvas from SVG canvas, document PDF, or `PictureRecorder`.
//! Document based Canvas and other Canvas subclasses reference `BaseDevice` describing the
//! destination.
//!
//! Canvas can be constructed to draw to Bitmap without first creating raster surface.
//! This approach may be deprecated in the future.

use std::ffi::c_void;
use std::rc::Rc;

use crate::core::bitmap::Bitmap;
use crate::core::color::PMColor;
use crate::core::image_info::ImageInfo;
use crate::core::point::IPoint;
use crate::core::surface_props::SurfaceProps;

pub struct Canvas {}

impl Canvas {
    /// Allocates raster Canvas that will draw directly into pixels.
    ///
    /// Canvas is returned if all parameters are valid.
    ///
    /// Valid parameters include:
    /// - `info` dimensions are zero or positive;
    /// - `info` contains `ColorType` and AlphaType supported by raster surface;
    /// - `pixels` is not nullptr;
    /// - `row_bytes` is zero or large enough to contain info width pixels of `ColorType`.
    ///
    /// Pass zero for `row_bytes` to compute `row_bytes` from `info` width and size of pixel.
    /// If `row_bytes` is greater than zero, it must be equal to or greater than
    /// `info` width times bytes required for `ColorType`.
    ///
    /// Pixel buffer size should be info height times computed `row_bytes`.
    /// Pixels are not initialized.
    /// To access pixels after drawing, call `flush()` or `peek_pixels()`.
    ///
    /// Parameters:
    /// - `info`: width, height, ColorType, AlphaType, ColorSpace, of raster surface;
    ///           width, or height, or both, may be zero
    /// - `pixels`: pointer to destination pixels buffer
    /// - `row_bytes`: interval from one SkSurface row to the next, or zero
    /// - `props`: LCD striping orientation and setting for device independent fonts; may be nullptr
    ///
    /// Returns Canvas if all parameters are valid; otherwise, nullptr
    pub fn new_raster_direct(
        _info: &ImageInfo,
        _pixels: *mut c_void,
        _row_bytes: usize,
        _props: Option<&SurfaceProps>,
    ) -> Option<Self> {
        todo!()
    }

    /// Allocates raster Canvas specified by inline image specification.
    ///
    /// Subsequent Canvas calls draw into pixels.
    ///
    /// `ColorType` is set to `ColorType::N32`.
    /// `AlphaType` is set to AlphaType::Premul`.
    ///
    /// To access pixels after drawing, call `flush()` or `peek_pixels()`.
    ///
    /// Canvas is returned if all parameters are valid.
    /// Valid parameters include:
    /// - `width` and `height` are zero or positive;
    /// - `pixels` is not nullptr;
    /// - `row_bytes` is zero or large enough to contain width pixels of `ColorType::N32`.
    ///
    /// Pass zero for `row_bytes` to compute row_bytes from width and size of pixel.
    /// If `row_bytes` is greater than zero, it must be equal to or greater than
    /// width times bytes required for `ColorType`.
    ///
    /// Pixel buffer size should be height times `row_bytesi`.
    ///
    /// Parameters:
    /// - `width`:  pixel column count on raster surface created; must be zero or greater
    /// - `height`: pixel row count on raster surface created; must be zero or greater
    /// - `pixels`: pointer to destination pixels buffer; buffer size should be height times `row_bytes`
    /// - `row_bytes`: interval from one Surface row to the next, or zero
    ///
    /// Returns Canvas if all parameters are valid; otherwise, nullptr
    pub fn new_raster_direct_n32(
        width: i32,
        height: i32,
        pixels: *mut PMColor,
        row_bytes: usize,
    ) -> Option<Self> {
        return Self::new_raster_direct(
            &ImageInfo::new_n32_premul(width, height, None),
            pixels as _,
            row_bytes,
            None,
        );
    }

    /// Creates an empty Canvas with no backing device or pixels,
    /// with a width and height of zero.
    ///
    /// Returns empty Canvas
    ///
    /// example: Canvas_empty_constructor
    #[must_use]
    #[inline]
    pub const fn new() -> Self {
        Self {}
    }

    /// Creates Canvas of the specified dimensions without a Surface.
    ///
    /// Used by subclasses with custom implementations for draw member functions.
    ///
    /// If `props` equals nullptr, `SurfaceProps` are created with `SurfaceProps::InitType` settings,
    /// which choose the pixel striping direction and order.
    /// Since a platform may dynamically change its direction when the device is rotated,
    /// and since a platform may have multiple monitors with different characteristics,
    /// it is best not to rely on this legacy behavior.
    ///
    /// Parameters:
    /// - `width`: zero or greater
    /// - `height`: zero or greater
    /// - `props`: LCD striping orientation and setting for device independent fonts; may be nullptr
    ///
    /// Returns Canvas placeholder with dimensions
    ///
    /// example: Canvas_int_int_const_SurfaceProps_star
    pub fn with_width_height(_width: i32, _height: i32, _props: Option<&SurfaceProps>) -> Self {
        todo!()
    }

    /// Private.
    ///
    /// For internal use only.
    fn with_device(_device: Rc<Device>) -> Self {
        todo!()
    }

    /// Constructs a canvas that draws into bitmap.
    ///
    /// Sets PixelGeometry::Unknown in constructed Surface.
    ///
    /// `Bitmap` is copied so that subsequently editing bitmap will not affect
    /// constructed Canvas.
    ///
    /// May be deprecated in the future.
    ///
    /// Parameters:
    /// - `bitmap`: width, height, ColorType, AlphaType, and pixel storage of raster surface
    ///
    /// Returns Canvas that can be used to draw into bitmap
    ///
    /// example: Canvas_copy_const_Bitmap
    pub fn with_bitmap(_bitmap: Bitmap) -> Self {
        todo!()
    }

    /// Constructs a canvas that draws into bitmap.
    ///
    /// Use `props` to match the device characteristics, like LCD striping.
    ///
    /// `bitmap` is copied so that subsequently editing bitmap will not affect
    /// constructed Canvas.
    ///
    /// Parameters:
    /// - `bitmap`: width, height, ColorType, AlphaType, and pixel storage of raster surface
    /// - `props`: order and orientation of RGB striping; and whether to use device independent fonts
    ///
    /// Returns Canvas that can be used to draw into bitmap
    ///
    /// example: Canvas_const_Bitmap_const_SurfaceProps
    pub fn with_bitmap_props(_bitmap: Bitmap, _props: SurfaceProps) -> Self {
        todo!()
    }

    /// Returns `ImageInfo` for Canvas.
    ///
    /// If Canvas is not associated with raster surface or GPU surface,
    /// returned `ColorType` is set to `ColorType::Unknown`.
    ///
    /// Returns dimensions and `ColorType` of Canvas
    ///
    /// example: Canvas_imageInfo
    #[must_use]
    pub fn image_info(&self) -> ImageInfo {
        unimplemented!()
    }

    /// Copies `SurfaceProps`, if Canvas is associated with raster surface or
    /// GPU surface, and returns true. Otherwise, returns false and leave props unchanged.
    ///
    /// Parameters:
    /// - `props`  storage for writable SurfaceProps
    ///
    /// Returns true if SurfaceProps was copied
    ///
    /// DEPRECATED: Replace usage with `get_base_props()` or `get_top_props()`
    ///
    /// example: Canvas_getProps
    pub const fn get_props(&self, _props: &SurfaceProps) -> bool {
        todo!()
    }

    /// Returns the `SurfaceProps` associated with the canvas
    /// (i.e., at the base of the layer stack).
    ///
    /// Returns base `SurfaceProps`
    pub const fn get_base_props(&self) -> SurfaceProps {
        todo!()
    }

    /// Returns the `SurfaceProps` associated with the canvas that are currently active
    /// (i.e., at the top of the layer stack).
    ///
    /// This can differ from getBaseProps depending on the flags passed to saveLayer
    /// (see SaveLayerFlagsSet).
    ///
    /// Returns `SurfaceProps` active in the current/top layer
    pub const fn get_top_props(&self) -> SurfaceProps {
        todo!()
    }

    /// Creates Surface matching info and props, and associates it with Canvas.
    ///
    /// Returns nullptr if no match found.
    ///
    /// If props is nullptr, matches SurfaceProps in Canvas. If props is nullptr
    /// and Canvas does not have SurfaceProps, creates Surface with default SurfaceProps.
    ///
    /// Parameters:
    /// - `info`: width, height, ColorType, AlphaType, and ColorSpace
    /// - `props`: SurfaceProps to match; may be nullptr to match Canvas
    ///
    /// Returns Surface matching info and props, or nullptr if no match is available
    ///
    /// example: Canvas_makeSurface
    pub fn make_surface(
        &mut self,
        _info: &ImageInfo,
        _props: Option<&SurfaceProps>,
    ) -> Rc<Surface> {
        todo!();
    }

    /// Sometimes a canvas is owned by a surface.
    ///
    /// If it is, getSurface() will return a bare pointer to that surface,
    /// else this will return nullptr.
    pub fn get_surface_mut(&self) -> &Surface {
        todo!()
    }

    /// Returns the pixel base address, ImageInfo, row_bytes, and origin if the pixels
    /// can be read directly.
    ///
    /// The returned address is only valid while Canvas is in scope and unchanged.
    /// Any Canvas call or Surface call may invalidate the returned address
    /// and other returned values.
    ///
    /// If pixels are inaccessible, info, row_bytes, and origin are unchanged.
    ///
    /// Parameters:
    /// - `info`: storage for writable pixels' ImageInfo; may be nullptr
    /// - `row_bytes`: storage for writable pixels' row bytes; may be nullptr
    /// - `origin`: storage for Canvas top layer origin, its top-left corner; may be nullptr
    ///
    /// Returns address of pixels, or nullptr if inaccessible
    ///
    /// example: Canvas_accessTopLayerPixels_a
    /// example: Canvas_accessTopLayerPixels_b
    pub fn access_top_layer_pixels(
        &mut self,
        _info: &mut ImageInfo,
        _row_bytes: &mut usize,
        _origin: &mut IPoint,
    ) -> *mut c_void {
        todo!()
    }
}

impl Drop for Canvas {
    /// Draws saved layers, if any.
    ///
    /// Frees up resources used by Canvas.
    ///
    /// example: Canvas_destructor
    fn drop(&mut self) {
        todo!()
    }
}

/*
pub trait CanvasTrait {
    /// Gets the size of the base or root layer in global canvas coordinates.
    ///
    /// The origin of the base layer is always (0,0). The area available for drawing may be
    /// smaller (due to clipping or saveLayer).
    ///
    /// Returns integral width and height of base layer.
    ///
    /// example: Canvas_getBaseLayerSize
    fn get_base_layer_size(&self) -> ISize;

    /// Returns Ganesh context of the GPU surface associated with Canvas.
    ///
    /// Returns GPU context, if available; nullptr otherwise
    ///
    /// example: Canvas_recordingContext
    fn recording_context(&self) -> &GrRecordingContext;


    /// Returns Recorder for the GPU surface associated with Canvas.
    ///
    /// Returns Recorder, if available; nullptr otherwise
    fn recorder(&self) -> &grphite::Recorder;
}
*/
